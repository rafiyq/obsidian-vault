Using Terraform, you’ll create a database instance and deploy it via a **bastion host** (also known as a **jump server**). The bastion host acts as a secure bridge, allowing authorized users from the public internet to access resources within a private network. 

To access the private network, users must establish an **SSH (Secure Shell)** connection to the bastion host. This connection is secured using an SSH key pair, which authenticates the user’s identity. Once authenticated, the bastion host forwards the user’s requests to the internal network.

![[c2w3_lab_bastion_host.svg]]

Architectural diagram of the resources 
Overview of the lab's steps

The diagram of the bastion host architecture consists of:
- An **RDS database instance** hosted inside a **private subnet** of a VPC.
- An **EC2 instance** acting as the bastion host, residing in a **public subnet** within the same VPC. This allows the EC2 instance to receive external traffic from the public internet and securely relay it to the internal database.

For this lab, the VPC and its subnets (both private and public) are pre-created and provided for you. You’ll define these as **data blocks** in your Terraform configuration files and use their information to create the RDS database and EC2 instances.

When creating the EC2 instance, you’ll generate an **SSH key pair**. The public key will be stored in the EC2 instance, while the private key will be saved in a separate file. This key pair encrypts and decrypts messages between the external user and the bastion host during an SSH connection, ensuring secure authentication.

After creating the resources with Terraform, you can use the private key to connect to the RDS database via an SSH connection through the bastion host. However, since SSH is not supported in the provided lab environment, you’ll only see the syntax for the SSH connection, which can be used in any external environment.

The lab provides Terraform files to help you create the database and EC2 instances. To complete the configuration, you’ll need the IDs of the VPC and its subnets, which are created using **CloudFormation** as part of the lab setup. You can find these IDs in the **CloudFormation stack outputs** in the AWS Management Console.

The main goal of the lab is for you to practice the Terraform syntax to create the resources of the lab. To create the database in EC2 instances, you're provided with the Terraform files that you'll need to complete. For that, you'll first need the IDs of the VPC and its subnets that are provided to you. These resources are created using CloudFormation as part of the lab setup. To access them, you can go to the console and look for CloudFormation in the search bar, and then click on the ID of the provided stack. On the right, click on the tab Outputs. Here you'll see a list of the resources created using CloudFormation behind the scenes. If you scroll down, you can find the IDs of the VPC and its subnets under the column value. 


Now let's do a quick tour for the Terraform files that are provided to you. The configuration files for the resources of the bastion host architecture are collected inside a module labeled as bastion host. The Terraform files are organized as shown here into variables, outputs, providers, and a file for each resource, EC2, RDS, and network. Remember that Terraform will concatenate all these configuration files together, and that splitting them into separate files is just for readability and ease of maintenance. In the providers file, you'll notice that the list of the required providers not only include AWS, but also other providers, which are local, random, and TLS. These are utility providers that provide functionalities you can use when creating your resources. You will use random to generate a random value for the database password, TLS to create the SSH key pair, and local to create a file to store the private key for the SSH key pair. I encourage you to check out the documentation for each of these providers in the Terraform registry. Now in the AWS block, note that the region and project name are specified through the use of variables. The network file contains the data blocks for the VPC and its subnets. In the lab, you will complete this part and specify the IDs of the subnet and VPC using the corresponding variables that are declared in the file variables. If you scroll down, you will see that the network file also contains the definition for the security groups of the bastion host and RDS. The security groups are configured so that the bastion host can receive SSH connection from the public internet, and the database can receive traffic only from the bastion host. You will use these network resources in the RDS and EC2 configurations. In the RDS file, you have three resource blocks. The third block contains the arguments that you will need to specify to create an RDS instance, such as a server instance type, allocated storage, subnet group, security group IDs, the type of engine, which is Postgres in this case, port number, the database username and password. You'll fill out the values for some of these arguments. The first resource block corresponds to the resource random ID from the random provider. This resource will generate a random number that you will assign to the database password. And the second block will create a subnet group which contains the IDs of the two private subnets that are provided to you. You will use this resource to configure the subnet group for the RDS database. Note that you have to specify two private subnets instead of one. This is because RDS is designed to expect at least two subnets in case you want to later switch to multi-availability zone deployment. In the EC2 file, there are also several resource blocks. The last block contains the configuration for the EC2 instance. You've already seen some of the attributes in the previous video, such as the AMI, instance type and subnet ID. In this lab, you'll also need to specify other attributes, such as the ID of its security group and key name. The key name represents the name of the SSH key pair that you need to associate to the bastion host. To do so, you'll use the first resource block, TLS private key, to generate the key pair. The second resource block, local file, creates a file for you to store the private key from the pair. And the resource AWS key pair block will register the public key with AWS so you can use its key name inside the configuration of the EC2 instance. These resource files expect some input variables that are declared in the file variables. The file contains variables that designate the project name, AWS region, the IDs of the VPC and its subnets, and the username for the database. The variables that correspond to the VPC and its subnets do not have a default value, so you'll need to assign values to these variables outside the module in the tf.vars file. The module also has some output values that are listed in the file outputs. You'll be tasked to complete this file to define the output values such as the database host, port, username, password, and the DNS of the bastion host. You'll need to export this information in order to connect to the database after you create the resources. We already discussed that everything in a module is encapsulated and hidden from the root directory, so in order to assign values to the module variables and to use its output values, you need to declare the module in the root directory. So here in this main file, the module is declared and you can see that values are assigned to its input variables and also using variables. This is why the root directory also contains a variables file that contains a similar list to the module variables. The variables that correspond to the VPC and its subnets do not have default values, and so you need to assign values to these variables in the tf.vars file using the IDs from the CloudFormation stack. The root directory also contains an outputs file that contains a list of the outputs exported from the module. The additional file you see here is the backend file, which contains a backend block that allows you to define where Terraform should store its state data files. Every time you run Terraform, the file terraform.tfstate is created or updated to keep track of the state of your underlying architecture and its configuration. This file contains information that maps the resource instances declared in the configuration to the actual AWS objects. You can locally store this state file, but if you're working with a team on the same collection of resources, you would need to share this state file with the team by storing it in a remote repo like an S3 bucket. In this lab, you will store the file locally and define the path within the backend block. So now it's your turn to practice working with Terraform on this architectural example. After you complete the configuration files, you will run Terraform to create your resources. At the end, you will experiment connecting to the database via the bastion host. After you finish the lab, join me in the next lesson to go over the second pillar of Data Ops, data observability and monitoring.